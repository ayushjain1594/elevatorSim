from elevator import Elevator, Task

class ElevatorControl:
	"""Object of this class have one or more Elevator objects in 
	its control to serve the simulation requests generated by 
	TrafficGenerator objects"""

	def __init__(self, sim_env, control_id, floors: tuple, num_elevators: int, 
		floor_height: float, max_speed: float, max_accel: float):

		self.ec_id = control_id
		self.env = sim_env
		self.floors = floors

		if isinstance(num_elevators, int):
			if num_elevators >= 1:
				self.elevators = {e_id: Elevator(sim_env, floors, floor_height, 
					max_speed, max_accel) 
				for e_id in range(1, num_elevators + 1)
				}
			else:
				raise ValueError('Number of elevators must be greater than ' + 
					'equal to 1')
		else:
			raise ValueError('Number of elevators must be integer')


	def get_current_states(self, e_id=None):
		"""Method returns states of each elevator that is 
		in control by self"""
		if e_id in self.elevators:
				return {e_id: self.elevators[e_id].current_state}
		else:
			return {e_id: elevator.current_state 
				for e_id, elevator in self.elevators.items()}

		return {}

	def select_elevator(self, floor_at):
		"""Method selects one elevator from (possibly) multiple"""
		if len(self.elevators) == 1:	
			# return only available elevator
			return next(iter(self.elevators))

		else:
			# choose the closest one (change this later to add
			# direction)
			delta = 9999
			selected_e_id = next(iter(self.elevators))
			for e_id, state in self.get_current_states():
				if abs(state - floor_at) < delta:
					delta = abs(state - floor_at)
					selected_e_id = e_id
				if delta == 0:
					break
			return selected_e_id

	def create_task(self, e_id, task_type, floor=None, floor_from=None, 
		floor_to=None, count=None, specific_index=None):
		"""
		Method creates an object of class Task and adds to tasks for 
		the specified elevator, with an option to add at a particular
		position.
		"""
		# two formats of task keys
		if task_type in ['hold', 'open door', 'close door']:
			# stationary tasks
			key = (task_type, floor, round(self.env.now, 1))
		else:
			# move tasks
			key = (task_type, floor_from, floor_to, round(self.env.now, 1))

		# add key to list of task keys
		if specific_index is None:
			self.elevators[e_id].task_keys.append(key)
		
		else:
			self.elevators[e_id].task_keys.insert(specific_index, key)

		# add key, Task Object pair to task dictionary
		try:
			self.elevators[e_id].tasks[key] = \
				Task(self.elevators[e_id], task_type, floor, 
					floor_from, floor_to, count)
		except ValueError as err:
			print(f'Error occured creating task {task_type},'+\
			f'floor {floor}, floor_from {floor_from} floor_to {floor_to}')

	def position_task(self, e_id, floor_from, floor_to):
		pass

	def strictly_less(a, b, dir):
		if dir > 0:
			return True if a < b else False
		else:
			return True if b < a else False

	def strictly_greater(a, b, dir):
		if dir > 0:
			return True if a > b else False
		else:
			return True if b > a else False

	def add_update_tasks(self, e_id, floor_from, floor_to, count, starting_index=0):
		"""Method takes request and converts them into tasks for the 
		selected elevator. The method then adds them to elevator's list
		of tasks. The method may also update previously assigned tasks 
		if multiple requests can be scheduled more efficiently"""
		if e_id not in self.elevators:
			raise KeyError('Invalid elevator id provided')

		current_state = self.get_current_states(e_id)
		direction = self.elevators.get(e_id).get_current_direction()
		current_task_key = self.elevators.get(e_id).current_task_key
		req_dir = 1 if floor_to > floor_from else -1

		flag = 0

		try:
			current_index = starting_index
			while current_index < len(self.elevators.get(e_id).task_keys) and \
			flag == 0:

				next_task_key = self.elevators.get(e_id).task_keys[current_index]
				key_iterator = iter(next_task_key)
				# get task type, such as 'move', 'doors', etc
				next_task_type = next(key_iterator, None)

				if next_task_type == 'move':

					move_task_from = next(key_iterator, None)
					move_task_to = next(key_iterator, None)
					move_task_dir = 1 if move_task_to > move_task_from else -1

					if move_task_dir == req_dir:

						if strictly_less(move_task_to, floor_to, req_dir):

							# Case 1
							#	O   N
							#		^
							#	^	|
							#	|	|
							#	|	|
							#		|
							if strictly_greater(move_task_from, floor_from, req_dir):
								pass

							# Case 2
							#	O   N
							#		^
							#	^	|
							#	|	|
							#	|	|
							if move_task_from == floor_from:
								prev_hold_task_key = self.elevators.get(
									e_id).task_keys[current_index-2]
								prev_door_task_key = self.elevators.get(
									e_id).task_keys[current_index-1]
								self.elevators.get(e_id).tasks[prev_door_task_key].update_count(count)
								self.elevators.get(e_id).tasks[prev_hold_task_key].update_count(count)
								
								self.elevators.get(e_id).tasks[next_task_key].update_count(count)
								self.add_update_tasks(e_id, move_task_to, floor_to, count, current_index+1)
								flag = 1
							

							# Case 3
							#	O   N
							#		^
							#	^	|
							#	|	|
							#	|
							if strictly_less(move_task_from, floor_from, req_dir) and \
							strictly_greater(move_task_to, floor_from, req_dir):
								orig_count = self.elevators.get(e_id).tasks[next_task_key].count
								del self.elevators.get(e_id).tasks[next_task_key]
								del self.elevators.get(e_id).task_keys[current_index]
								self.create_task(e_id, 'move', floor_from=move_task_from, 
									floor_to=floor_from, count=orig_count, 
									specific_index=current_index)
								self.create_task(e_id, 'open door', floor=floor_from, 
									count=count, specific_index=current_index+1)
								self.create_task(e_id, 'hold', floor=floor_from,
									count=count, specific_index=current_index+2)
								self.create_task(e_id, 'close door', floor=floor_from, 
									count=count, specific_index=current_index+3)
								self.create_task(e_id, 'move', floor_from=floor_from,
									floor_to=move_task_to, count=orig_count+count,
									specific_index=current_index+4)
								self.add_update_tasks(e_id, move_task_to, floor_to, count, current_index+5)
								flag = 1

						elif strictly_greater(move_task_to, floor_to, req_dir):
							
							# Case 4
							#	O   N
							#	^
							#	|	^
							#	|	|
							#		|
							if strictly_greater(move_task_from, floor_from, req_dir) and \
							strictly_less(move_task_from, floor_to, req_dir):
								pass

							# Case 5
							#	O   N
							#	^
							#	|	^
							#	|	|
							#	|	|
							if task_from == from_:
								prev_hold_task_key = self.elevators.get(
									e_id).task_keys[current_index-2]
								prev_door_task_key = self.elevators.get(
									e_id).task_keys[current_index-1]
								self.elevators.get(e_id).tasks[prev_door_task_key].update_count(count)
								self.elevators.get(e_id).tasks[prev_hold_task_key].update_count(count)

								orig_count = self.elevators.get(e_id).tasks[next_task_key].count
								del self.elevators.get(e_id).tasks[next_task_key]
								del self.elevators.get(e_id).task_keys[current_index]
								self.create_task(e_id, 'move', 
									floor_from=move_task_from, floor_to=floor_to, 
									count=orig_count+count, specific_index=current_index)
								self.create_task(e_id, 'open door', floor=floor_to, 
									count=count, specific_index=current_index+1)
								self.create_task(e_id, 'hold', floor=floor_to, 
									count=count, specific_index=current_index+2)
								self.create_task(e_id, 'close door', floor=floor_to, 
									count=count, specific_index=current_index+3)
								self.create_task(e_id, 'move',
									floor_from=floor_to, floor_to=move_task_to, 
									count=orig_count, specific_index=current_index+4)
								flag = 1

							# Case 6
							#	O   N
							#	^	
							#	|	^
							#	|	|
							#	|	|
							#	|
							if strictly_less(move_task_from, floor_from, req_dir):
								
								orig_count = self.elevators.get(e_id).tasks[next_task_key].count
								
								del self.elevators.get(e_id).tasks[next_task_key]
								del self.elevators.get(e_id).task_keys[current_index]
								
								
								self.create_task(e_id, 'move', floor_from=move_task_from,
									floor_to=floor_from, count=orig_count,
									specific_index=current_index)

								self.create_task(e_id, 'open door', floor=floor_from,
									count=count, specific_index=current_index+1)
								self.create_task(e_id, 'hold', floor=floor_from, 
									count=count, specific_index=current_index+2)
								self.create_task(e_id, 'close door', floor=floor_from,
									count=count, specific_index=current_index+3)

								self.create_task(e_id, 'move', floor_from=floor_from, 
									floor_to=floor_to, count=orig_count+count,
									specific_index=current_index+4)

								self.create_task(e_id, 'open door', floor=floor_to,
									count=count, specific_index=current_index+5)
								self.create_task(e_id, 'hold', floor=floor_to, 
									count=count, specific_index=current_index+6)
								self.create_task(e_id, 'close door', floor=floor_to,
									count=count, specific_index=current_index+7)

								self.create_task(e_id, 'move', floor_from=floor_to,
									floor_to=move_task_to, count=orig_count,
									specific_index=current_index+8)
								flag = 1
								

						else:
							# move_task_to == floor_to
							# Case 7
							#	O   N
							#	^	^
							#	|	|
							#	|	|
							#		|
							# ***First move in this direction otherwise
							# will fall under case 4***

							# Case 8
							#	O   N
							#	^	^
							#	|	|
							#	|	|
							#	|	|
							if move_task_from == floor_from:
								
								# update count in 'close door' and 'hold'
								prev_hold_task_key = self.elevators.get(
									e_id).task_keys[current_index-2]
								prev_door_task_key = self.elevators.get(
									e_id).task_keys[current_index-1]
								self.elevators.get(e_id).tasks[prev_door_task_key].update_count(count)
								self.elevators.get(e_id).tasks[prev_hold_task_key].update_count(count)

								self.elevators.get(e_id).tasks[next_task_key].update_count(count)

								foll_door_task_key = self.elevators.get(
									e_id).task_keys[current_index+1]
								foll_hold_task_key = self.elevators.get(
									e_id).task_keys[current_index+2]
								self.elevators.get(e_id).tasks[foll_door_task_key].update_count(count)
								self.elevators.get(e_id).tasks[foll_hold_task_key].update_count(count)
								flag = 1

				current_index += 1

		except KeyError as err:
			print(err)
			if err in self.elevators.get(e_id).tasks.keys():
				print("key was present")
			else:
				print("key not in Task.keys()")
			if err in self.elevators.get(e_id).task_keys:
				print("key was present in task_keys list")
			else:
				print("key not in task_keys either")
			print(self.elevators.get(e_id).tasks.keys())

		if flag == 1:
			print("Added request task in middle")

		if flag == 0:
			if len(self.elevators.get(e_id).task_keys) > 0:
				last_task_floor = self.elevators.get(e_id).task_keys[-1][1]
				self.create_task(e_id, 'move', floor_from=last_task_floor, 
					floor_to=floor_from, count=count)
			else:
				self.create_task(e_id, 'move', floor_from=current_state[e_id], 
					floor_to=floor_from, count=count)

			self.create_task(e_id, 'open door', floor=floor_from, count=count)

			self.create_task(e_id, 'hold', floor=floor_from, count=count)

			self.create_task(e_id, 'close door', floor=floor_from, count=count)

			self.create_task(e_id, 'move', floor_from=floor_from, floor_to=floor_to, count=count)

			self.create_task(e_id, 'open door', floor=floor_to, count=count)

			self.create_task(e_id, 'hold', floor=floor_to, count=count)

			self.create_task(e_id, 'close door', floor=floor_to, count=count)
			print("Added request task at the end")
		#print(self.elevators.get(e_id).tasks.keys())

	def request_service(self, floor_at: int, floor_to: int, count: int):
		""" Method is the primary process created by a request in
		simulation """

		if (floor_at not in self.floors) or (floor_to not in self.floors):
			raise ValueError('Request outside service floors')

		# find an elevator to allocate the request
		selected_e_id = self.select_elevator(floor_at)

		# Convert request into tasks for selected elevator to process
		self.add_update_tasks(selected_e_id, floor_at, floor_to, count)

		# If elevator was idle, call to start processing tasks
		if self.elevators.get(selected_e_id).current_task_key is None:
			#self.env.process(self.elevators.get(selected_e_id).process_tasks())
			pass