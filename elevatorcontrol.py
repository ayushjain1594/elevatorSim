from elevator import Elevator, Task

class ElevatorControl:
	"""Object of this class have one or more Elevator objects in 
	its control to serve the simulation requests generated by 
	TrafficGenerator objects"""

	def __init__(self, sim_env, control_id, floors: tuple, 
		num_elevators: int, floor_height: float, 
		max_speed: float, max_accel: float):

		self.ec_id = control_id
		self.env = sim_env
		self.floors = floors

		if isinstance(num_elevators, int):
			if num_elevators >= 1:
				self.elevators = {
					e_id: Elevator(sim_env, floors, 
						floor_height, max_speed, max_accel
					) for e_id \
					in range(1, num_elevators + 1)
				}

			else:
				raise ValueError('Number of elevators must be greater than ' + 
					'equal to 1')
		else:
			raise ValueError('Number of elevators must be integer')


	def get_current_states(self, e_id=None):
		"""Method returns states of each elevator that is 
		in control by self"""
		if e_id in self.elevators:
				return {e_id: self.elevators[e_id].current_state}
		else:
			return {e_id: elevator.current_state 
				for e_id, elevator in self.elevators.items()}

		return {}

	def select_elevator(self, floor_at):
		"""Method selects one elevator from (possibly) multiple"""
		if len(self.elevators) == 1:	
			# return only available elevator
			return next(iter(self.elevators))

		else:
			# choose the closest one (change this later to add
			# direction)
			delta = 9999
			selected_e_id = next(iter(self.elevators))
			for e_id, state in self.get_current_states():
				if abs(state - floor_at) < delta:
					delta = abs(state - floor_at)
					selected_e_id = e_id
				if delta == 0:
					break
			return selected_e_id

	def create_task(self, e_id, task_type, floor=None, floor_from=None, 
		floor_to=None, count=None, specific_index=None):
		"""
		Method creates an object of class Task and adds to tasks for 
		the specified elevator, with an option to add at a particular
		position.
		"""
		# two formats of task keys
		if task_type in ['hold', 'open door', 'close door']:
			# stationary tasks
			key = (task_type, floor, round(self.env.now, 1))
		else:
			# move tasks
			if floor_from == floor_to:
				raise ValueError("Floor from and to should not be same")

			key = (task_type, floor_from, floor_to, round(self.env.now, 1))

		# add key to list of task keys
		if specific_index is None:
			self.elevators[e_id].task_keys.append(key)
		
		else:
			self.elevators[e_id].task_keys.insert(specific_index, key)

		# add key, Task Object pair to task dictionary
		try:
			self.elevators[e_id].tasks[key] = \
				Task(self.elevators[e_id], task_type, floor, 
					floor_from, floor_to, count)
		except ValueError as err:
			print(f'Error occured creating task {task_type},'+\
			f'floor {floor}, floor_from {floor_from} floor_to {floor_to}')

	def delete_task(self, e_id, task_index):
		try:
			task_key = self.get_task_key(e_id,task_index)
			del self.elevators.get(e_id).tasks[task_key]
			del self.elevators.get(e_id).task_keys[task_index]
		except KeyError as err:
			print(f'Arguments: e_id={e_id} and task_index={task_index}')
			len_ = len(self.elevators.get(e_id).tasks)
			print(f'Error occured while deleting task with len of tasks {len_}')
			print(err)
	
	def create_move_task(self, e_id, from_, to_, index_=None, count_=0):
		self.create_task(e_id, 'move', floor_from=from_, floor_to=to_,
			count=count_, specific_index=index_)

	def create_non_move_task(self, e_id, type_, floor_, count_=0, index_=None):
		self.create_task(e_id, type_, floor=floor_, count=count_, 
			specific_index=index_)

	def get_task_key(self, e_id, index_):
		try:
			return self.elevators.get(e_id).task_keys[index_]
		except IndexError:
			print(f"Error occured querying task keys at {index_}")
			return ()

	def get_task_count(self, e_id, index_):
		task_key = self.get_task_key(e_id, index_)
		try:
			return self.elevators.get(e_id).tasks[task_key].count
		except IndexError:
			print(f"Error occured querying tasks with key at {index_}")
			return 0

	def get_task_dir(self, e_id, index_):
		task_key = self.get_task_key(e_id, index_)
		try:
			return 1 if task_key[2] > task_key[1] else -1
		except IndexError:
			print(f"Error occured querying task key retrived from {index_}")

	def strictly_less(self, a, b, dir):
		if dir > 0:
			return True if a < b else False
		else:
			return True if b < a else False

	def strictly_greater(self, a, b, dir):
		if dir > 0:
			return True if a > b else False
		else:
			return True if b > a else False

	def add_update_tasks(self, e_id, floor_from, floor_to, count=0, start_index=0):
		"""Method takes request and converts them into tasks for the 
		selected elevator. The method then adds them to elevator's list
		of tasks. The method may also update previously assigned tasks 
		if multiple requests can be scheduled more efficiently"""
		if e_id not in self.elevators:
			raise KeyError('Invalid elevator id provided')

		current_state = self.get_current_states(e_id)
		direction = self.elevators.get(e_id).get_current_direction()
		current_task_key = self.elevators.get(e_id).current_task_key
		req_dir = 1 if floor_to > floor_from else -1

		flag = 0
		
		try:
			current_index = start_index
			non_move_tasks_count = 0
			while current_index < len(self.elevators.get(e_id).task_keys) \
			and flag == 0:

				next_task_key = self.get_task_key(e_id, current_index)
				key_iterator = iter(next_task_key)

				next_task_type = next(key_iterator, None)

				if next_task_type == 'move':

					task_from = next(key_iterator, None)
					task_to = next(key_iterator, None)
					move_task_dir = 1 if task_to > task_from else -1

					if move_task_dir == req_dir:

						if self.strictly_less(task_to, floor_to, req_dir):

							# Case 1
							#	O   N
							#		^
							#	^	|
							#	|	|
							#	|	|
							#		|
							if self.strictly_greater(task_from, floor_from, req_dir):
								print("Identified Case 1")
								if current_index == start_index:
									self.create_move_task(e_id, floor_from, 
										task_from, current_index)
									# now becomes case 2
									self.add_update_tasks(e_id, task_from, 
										floor_to, start_index=current_index+1)
								else:
									prev_task_key = self.get_task_key(e_id, 
										current_index-1)
									prev_task_fr = prev_task_key[1]
									
									self.delete_task(e_id, current_index-1)
									self.create_move_task(e_id, prev_task_fr, 
										floor_from, current_index-1)
									self.create_move_task(e_id, floor_from, 
										task_from,
										current_index)
									self.add_update_tasks(e_id, task_from, 
										floor_to,
										start_index=current_index+1)
									
								flag = 1

							# Case 2
							#	O   N
							#		^
							#	^	|
							#	|	|
							#	|	|
							if task_from == floor_from:
								print("Identified Case 2")
								if current_index+1 < \
								len(self.elevators.get(e_id).task_keys):
									subsequent_task_key = self.get_task_key(e_id, 
										current_index+1)
									if self.get_task_dir(e_id, current_index+1) == req_dir:
										self.add_update_tasks(e_id, task_to, floor_to, 
											start_index=current_index+1)
									else:
										subsequent_task_to = subsequent_task_key[2]
										
										self.delete_task(e_id, current_index+1)
										self.create_move_task(e_id, task_to, floor_to, 
											current_index+1)
										self.create_move_task(e_id, floor_to, 
											subsequent_task_to, current_index+2)
										
								else:
									self.add_update_tasks(e_id, task_to, floor_to, 
										start_index=current_index+1)
								flag = 1
							

							# Case 3
							#	O   N
							#		^
							#	^	|
							#	|	|
							#	|
							if self.strictly_less(task_from, floor_from, req_dir) and \
							self.strictly_greater(task_to, floor_from, req_dir):
								print("Identified Case 3")
								
								self.delete_task(e_id, current_index)
								self.create_move_task(e_id, task_from, 
									floor_from, current_index)
								self.create_move_task(e_id, floor_from,
									task_to, current_index+1)
								self.add_update_tasks(e_id, task_to,
									floor_to, start_index=current_index+1)
								flag = 1

						elif self.strictly_greater(task_to, floor_to, req_dir):
							
							# Case 4
							#	O   N
							#	^
							#	|	^
							#	|	|
							#		|
							if self.strictly_greater(task_from, floor_from, req_dir) and \
							self.strictly_less(task_from, floor_to, req_dir):
								print("Identified Case 4")
								if current_index == start_index:
									self.create_move_task(e_id, floor_from, 
										task_from, current_index)
									self.add_update_tasks(e_id, task_from, 
										floor_to, start_index=current_index+1)
								else:
									prev_task_key = self.get_task_key(e_id, 
										current_index-1)
									prev_task_fr = prev_task_key[1]
									self.delete_task(e_id, current_index-1)
									self.create_move_task(e_id, prev_task_fr,
										floor_from, current_index-1)
									self.create_move_task(e_id, floor_from,
										task_from, current_index)
									self.add_update_tasks(e_id, task_from, 
										floor_to, start_index=current_index+1)
								flag = 1

							# Case 5
							#	O   N
							#	^
							#	|	^
							#	|	|
							#	|	|
							if task_from == floor_from:
								print("Identified Case 5")
								self.delete_task(e_id, current_index)
								self.create_move_task(e_id, task_from, 
									floor_to, current_index)
								self.create_move_task(e_id, floor_to,
									task_to, current_index+1)
								flag=1

							# Case 6
							#	O   N
							#	^	
							#	|	^
							#	|	|
							#	|	|
							#	|
							if self.strictly_less(task_from, floor_from, req_dir):
								print("Identified Case 6")
								self.delete_task(e_id, current_index)
								self.create_move_task(e_id, task_from,
									floor_from, current_index)
								self.create_move_task(e_id, floor_from,
									floor_to, current_index+1)
								self.create_move_task(e_id, floor_to,
									task_to, current_index+2)
								flag = 1

						else:
							# task_to == floor_to
							# Case 7
							#	O   N
							#	^	^
							#	|	|
							#	|	|
							#		|
							# ***First move in this direction otherwise
							# will fall under case 4***
							if self.strictly_greater(task_from, floor_from, move_task_dir):
								print("Identified Case 7")
								if current_index == start_index:
									self.create_move_task(e_id, 
										floor_from, task_from,
										current_index)
									self.add_update_tasks(e_id,
										task_from, floor_to,
										start_index=current_index+1)

								else:
									prev_task_key = self.get_task_key(e_id, 
										current_index-1)
									prev_task_fr = prev_task_key[1]
									self.delete_task(e_id, current_index-1)
									self.create_move_task(e_id, prev_task_fr,
										floor_from, current_index-1)
									self.create_move_task(e_id, floor_from,
										task_from, current_index)
									self.add_update_tasks(e_di, task_from,
										floor_to, current_index+1)
								flag = 1

							# Case 8
							#	O   N
							#	^	^
							#	|	|
							#	|	|
							#	|	|
							if task_from == floor_from:
								print("Identified Case 8")
								flag = 1

							# Case 9
							#	O   N
							#	^	^
							#	|	|
							#	|	|
							#	|	|
							#	|
							if self.strictly_less(task_from, floor_from, move_task_dir):
								print("Identified Case 9")
								self.delete_task(e_id, current_index)
								self.create_move_task(e_id, task_from,
									floor_from, current_index)
								self.create_move_task(e_id, floor_from,
									task_to, current_index+1)
								flag=1

					non_move_tasks_count = 0
				else:
					non_move_tasks_count += 1
				current_index += 1

		except KeyError as err:
			print(err)
			if err in self.elevators.get(e_id).tasks.keys():
				print("key was present")
			else:
				print("key not in Task.keys()")
			if err in self.elevators.get(e_id).task_keys:
				print("key was present in task_keys list")
			else:
				print("key not in task_keys either")
			print(self.elevators.get(e_id).tasks.keys())

		if flag == 1:
			print("Added request task in middle")

		if flag == 0:
			# Request could not accomodated with others
			if len(self.elevators.get(e_id).task_keys) > 0:
				last_task_floor = self.elevators.get(e_id).task_keys[-1][2]
				if last_task_floor != floor_from:
					self.create_move_task(e_id, last_task_floor, 
						floor_from)

			else:
				if current_state[e_id] != floor_from:
					self.create_move_task(e_id, current_state[e_id], 
						floor_from)

			self.create_move_task(e_id, floor_from, floor_to)
			
			print("Added request task at the end")
		#print(self.elevators.get(e_id).task_keys)


	def request_service(self, floor_at: int, floor_to: int, count: int):
		""" Method is the primary process created by a request in
		simulation """

		if (floor_at not in self.floors) or (floor_to not in self.floors):
			raise ValueError('Request outside service floors')

		# find an elevator to allocate the request
		selected_e_id = self.select_elevator(floor_at)

		# Convert request into tasks for selected elevator to process
		self.add_update_tasks(selected_e_id, floor_at, floor_to, count)

		# If elevator was idle, call to start processing tasks
		if self.elevators.get(selected_e_id).current_task_key is None:
			self.env.process(self.elevators.get(selected_e_id).process_tasks())
			#pass